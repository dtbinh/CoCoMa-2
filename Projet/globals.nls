;to maj-belief-turtle [bel]
;  ; Mise a jour des informations relatives a une turtle, sert a eviter le cumul d'information et les doublons
;  let more-recent-found? false
;  foreach beliefs [
;    show length beliefs
;    show "1"
;    if (first bel = first ?) and (first item 1 ? = first item 1 bel) [ 
;      ; Si on trouve un ancien belief avec le meme id que le nouveau
;      ifelse  item 4 item 1 ? > item 4 item 1 bel [ ; Si le beliefs trouve est plus recent
;        set more-recent-found? true
;        show "not removed"
;        stop
;      ]
;      [
;        show word "removed " ?
;        remove-belief ?
;        ;add-belief bel
;        stop
;      ]
;    ]
;  ]
;  show "outside foreach"
;  if not more-recent-found? [ ; Si on a pas trouve de belief plus recent
;    show word "added " bel
;    add-belief bel ; On ajoute alors les nouvelles informations
;  ]
;  ;show more-recent-found?
;  
;end

to maj-belief-turtle [bel]
  ; Mise a jour des informations relatives a une turtle, sert a eviter le cumul d'information et les doublons
  let exists false
  foreach beliefs [
    if (first bel = first ?) and (first item 1 ? = first item 1 bel) [ 
      ; Si on trouve un ancien belief avec le meme id que le nouveau
      set exists true
      if item 4 item 1 bel > item 4 item 1 ? [ ; Si le belief trouvé est plus récent
        remove-belief ? ; on supprime l'ancien
        add-belief bel ; on ajoute le nouveau
      ]
    ]
    if exists [
      stop
    ]
  ]
  if not exists [
    add-belief bel
  ]
end

to turtle-look
  ;Analyse de l'environement et mise a jour de croyance

  let prox other turtles in-cone-nowrap vision 180 

  foreach  sort-on [who] prox [
    if [breed] of ? = enemies-ped or [breed] of ? = convois [
      let bel create-belief [side] of ? (list [who] of ? [xcor] of ? [ycor] of ? [zcor] of ? ticks) ; ticks
      maj-belief-turtle bel ; Mise a jour des croyance relative a cette turtle 
    ]
  ]
  if debug [
   show beliefs
  ]
end


to send-beliefs [receiver]
  
end
  
 

to set-prox-target
  ; On recherche un ennemi dans la base de recherche
  if target != nobody [ stop ] ; [ NOTE : on aura surement envie de faire autre chose par la suite, par exemple changer de cible si on en repere une plus proche ]
  
  foreach beliefs [ ; [ On pourait utiliser filter [...] pour potentielement plus de performances
     
    if first ? != side [ ; Pour tout les ennemies recenser
      let tmp turtle first item 1 ? 
 
      if tmp != nobody and not [dead?] of tmp and (target = nobody or distance tmp < distance target) [ ; On recherche le plus proche [ NOTE : Attention à la WARP-ZONE ! ]
        set target tmp 
      ]
    ]
  ]

  if target != nobody [ ; Si une cible a ete trouvee, on ajoute une intention de type chasse
    add-intention "chase-target" "chase-target? "
  ]
  
  move-randomly
  
end

to-report chase-target?
  ; Si la cible est morte ou hors du champ de vision, on arrete
  let tmp not (([dead?] of target) or (distance-nowrap target > vision) )
  if tmp [ set target nobody ]
  report  tmp
end

to chase-target
  if distance-nowrap target < range [ ; Si la cible est a portee de tir
    shoot-target ; On tire
  ]
  ifelse distance-nowrap target < vision [
    follow-target ; Sinon, si elle est encore visible, on la suit
  ]
  [
    
    ;On avance vers sa derniere position connue ?
    
  ]
end

to shoot-target
  if ticks - last-shot > 15 / simu-speed  [ ; Attention : la cadence de tir ne devrais pas etre defini ici
    if play-sounds [sound:play-note "GUNSHOT" 128 64 0.2]
    set last-shot ticks
    hatch-bullets 1 [ 
      if [breed] of myself = drones [ set damage 15 ]
      if [breed] of myself = enemies-ped [ set damage 10 ]
      set speed simu-speed * bullets-speed
      set shape "cannon";arrow 3"
      face-nowrap target
      setxyz xcor ycor zcor
    ]
  ]
end

to follow-target
  face-nowrap target ; On fait face a la cible
  ifelse [obstacle?] of patch-ahead speed
    [ find-path ]
    [ fd speed ] ; On avance vers elle
end

;to-report obstacle-ahead?
;  let turtle-heading heading
;  face-nowrap target
;  
;  let dst 1
;  let obs false
;  while [ dst <= distance target and obs = false ]
;  [
;    set obs [ obstacle? ] of patch-ahead dst
;    set dst dst + 1
;  ]
;  ; set back to initial heading
;  set heading turtle-heading
;  report obs
;end

to find-path
  lt 20
  if [ obstacle? ] of patch-ahead speed [ find-path ]
  fd speed
end

;to find-path
;  let p patch xcor ycor mapAlt
;  let path (plan-astar p [patch-here] of target false)
;  show p
;  ;show path
;end

to move-randomly
  ; move randomly if no ennemy near us
  if random 100 < 50 [ lt 2 ]
  if [ obstacle? ] of patch-ahead speed [ stop ]
  fd speed
end


  